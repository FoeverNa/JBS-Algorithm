# day2

## 추상 자료형

### 추상자료형(Abstract Data Type; ADT)

- 정의 : '값'과 '연산'의 집합으로 정의되는 논리적 행동을 가지는 오브젝트 클래스
  - 값과 연산이 모여있다는 것과 논리적인 행동이라는게 중요포인트
  - 논리적인 행동은 무엇을 한다 라는 것이지 어떻게 한다라는 것이 아니다
    - 어떻게라는 구현이 빠져있는 것이다
- 추상 자료형은 자료형의 수학적 모델로서, 사용자 입장에서 본 자료의 행동에 의해서 정의 된다. 이 '행동'은 가능한 값과 가능한 연산, 그리고 이 연산의 동작으로 이루어 진다
  - 사용자는 자료를 쓰는 주체를 의미 한다(우리들, 개발자들)
- ADT와 DS의 차이점은 구현이 되어 있는가 아닌가의 차이이다
  - ADT + 구현 = DS 이다
  - 수학적 모델(어떻게 한다는 구현은 빠져있고 무슨일이 일어나야되는지 정의만되어있다)



### 추상자료형과 자료 구조의 차이

- 실제로는 구분하기가 어렵다

  - 이름이 같은경우도 있고, 자료 구조는 구현 별로이름이 다를 수 있다

  - ex) Stack, Queue, LinkedList

  - List - ArrayList

    

- 추상 자료형과 자료 구조의 가장 큰 차이점은 **구현 여부**

  - 자료 구조는 실제로 구현되어 사용할수 있는 것이다.
  - 예를 들면 java에 interface와 abstract class와 연관이 깊다
    - ADT의 역할도 인터페이스의 역할과 같다
    - 개념적으로 정의를 하고 있따

  

## 배열(Arrays)

### 배열이란

- java에 배열과 같다.  - C familliy는 배열을 충실히 구현해놓았다
- 다루는 자료의 수가 많아질 떼, 이를 다루기 위해 사용하는 자료구조
- 하나의 변수에 여러 자료를 저장할 수 있으며, 반복문을 이용해 효율적으로 처리 가능하다
- 배열에서 인덱스는 유일무이한 식별자(Identifier)로 사용된다
  - 값이 같아도 다른자료로 인식이된다
  - 0이라는 식별자를 가진 자료는 하나밖에 없기에 0이라는 식별자에 값을 삽입하면 덮어쓰게 된다



### 배열의 특징

- 크기(Element의 개수)가 정해져 있다.

- 자료 구조에 기능(메소드)이 포함되어 있지 않다

  - 자료의 모음집일 뿐이다
  - 대신에 Arrays클래스에 스태틱메소드를 활용해 다루게 된다
    - C에서부터 내려온 것을 그대로 구현했기에 OOP방식이 아니고 이런식으로 처리하게 됬다

- 자료가 메모리상에 빈틈 없이 연속적으로 위치해 있다

- (그렇기에)인덱스를 활용하여 자료에 빠르게 접근할 수 있다.

  - O(1)로 빠르게 접근을 할수가 있게 된다. => random access라고한다.
    - 임의에 위치에 바로접근할수 있다라는 뜻
    - 참고로 Random Access Memory가 RAM이다 => 임의애 위치에 바로접근
      - 이거 반대가 옛날 하드디스크로 Sequencial Acess로 헤더가 문리적으로 접근하는것

- 배열을 만들때는 크기와 엘레멘트 종류를 알려줘야 한다

  - 한칸이 몇byte쓸지를 알고 전체 몇개를 사용할질알아야 메모리의 크기를 지정할 수 있기 때문이다
  - 자바에 경우 JVM에서 알아주지만 C같은 언어는 SystemCall을해서 OS에 메모리를 요청한다
  - 그럼 시작 메모리위치를 반환해주면 거기부터 이만큼쓰게 어플리케이션이 인식을 하게 된다
  - i*k+ 시작위치를 하면 바로 인덱스에 접근할 수 있게 된다

  

### 배열의 단점

- 배열의 길이는 생성 시 정해져, 변경할 수 없다

  - 가변 길이 배열은 배열의 크기를 변경할 때 마다 새 배열을 만든다

- Element를 제거할 경우, 배열에 빈 틈이 생긴다. => 단점보다는 특징

  - 기존 Element의 인덱스를 유지하기 위해 빈 틈을 유지한다.

  - 인덱스가 함부로 바뀌지 않는게 특징이다.

  - 사실 비운다는 개념도 확실치 않아서 데이터는 그자리에 있다고 보는게 맞지만 활용하는 입장에서 해당 데이터를 활용안한다는거을 알고 있을 뿐이다.

    - 엘레멘트 삭제라는게 존재하지 않는다는 것

      

### 배열의 활용

- 배열의 생성
- 자료의 삽입
  - 기존에 값이 존재한다면 인덱스에 값을 덮어써서 대체하게 된다
- 자료의 삭제
  - 삭제한다고 해도 값이 지워지지 않고 쓰레기값이 남아있게 되서 외부에서 사용할때 잘인지하고 사용해야 한다
- 자료의 색인
  - 인덱스를 알면 시작위치를 알면 데이터 타입의 byte*인덱스 해서 O(1)로 배열에 접근할 수 있게 된다
  - 강력하면서 배열을 쓰는 가장 중요한 이유 이다.

### Java와 배열

- Java에는 배열 자료구조가 있어, 저수준 동작을 구현할 수 있다



## 리스트(Lists)

### 리스트란

- 순차적인 데이터(Sequential Data)를 다르기 위한 추상 자료형(ADT)
  - 자료들의 순서를 가지고 있는 데이터
  - 배열과는 다르게 순서를 가지고 있어서 값을 중간에 넣으면 다른 순서도 변하게 된다
    - 인덱스가 아닌 순서에 의해서 식별된다?
- 리스트에는 동일한 값이 여럿 존재할 수 있으며, 이는 서로 다른 항목으로 구분된다.

### 리스트의 연산자(Operators)

- 비어있는 리스트를 생성하는 생성자
  - 배열처럼 만들어야 list를 생성되는 것은 아니고 그냥 리스트를 생성한다는개념이 있다
- 리스트가 비어있는지 확인하는 연산자
- 리스트의 앞에 개체를 삽입(prepedning)하는 연산자
  - ADT에는 실제 어떻게 구현할지에 대해선 안나와있고 값을 넣으면 맨앞에 들어간 결과가 나오는 것만 보여준다
    - 0번부터 값을 1부터 옮겨놓자라는 것은 실제로 구현에 내용이라고 생각하면된다
- appeding은 뒤에 값 붙여주는것
- 첫머리 head를 결정하는 연산자
  - 2번을 head로 하게됬다면 앞에걸버리고 2번을 0으로하는 리스트를 새로 만들겠다
- 주어진 인덱스에 해당하는 요소에 접근하는 연산자
  - Access 혹은 get
- 주어진 인덱스에 새로운 요소를 삽입하는 연산자
  - 중간에 삽입하면insert
- 주어진 인덱스에 해당하는 요소를 제거하는 연산자
  - revmove
  - 제거를하면 순번이 당겨진다

### 리스트의 구현

- 배열 리스트(Array List)

  - 배열을 기반으로 만들어진 리스트
    - 크기가 커지면 새로운 배열을 사용하기에 메모리에 연속성도 지켜진다
  - 각 연산의 복잡도
    - isEmpty(): O(1)
      - length가 0인지 체크하면 바로 상수로할수있따
    - prepend: 다 움직이니까니까 O(n)
    - append() : 조건부O(1)이고 capctiry가 꽉찼을 경우 O(n)이 되어야 한다
    - setHead(index) : O(1)
    - acess(index) : O(1)
    - isnert(item, index) : O(n)
      - 한칸씩 밀어지니까
    - remove(index): O(n)

  

- 연결 리스트(Linked List)

  - 값과 다음값에 연결된 노드로 구현되어있따

  - 각 연산의복잡도

    - isEmpty: O(1)

      - 첫번째 자료를 가르키는 Head가 Null을 가르키게 된다(하나만 체크하면 된다)

    - prepend() : O(1) 

      - 헤드의 순서만 바꿔주면된다

    - append() : O(n)

      - 헤드로부터 맨마지막을 찾아가는 access 시간이 걸려서 억울하게 O(n)
      - 그꼬리 순서만 바꾸주면됨

    - setHead(index):

      - On(n) ======================================>왜였지?
      - 헤드만 바꿔주면 그 이전값은 가비지 컬렉션된다

    - acess(index) : O(n)

      - 찾아가면서 acess해야되기때문에 O(n)

      - 그렇기  오래걸리는게 가장큰 단점이 된다

        - 그래서 사용하는게 배열을 만들어서 ref값을 넣어준다

        - 얘내가 가르키는건 임의에 위치가 된다

          - 그럼 referec가 nod처럼 사용되는 likedList 같은게 된다

        - => 링크드와 비슷하게 유연하게 구현이 가능해지는 것이다

          - 그대신 arrayList처럼 값을 하나지우면 다른값도 땡겨주어야 한다

            

    - insert

    - remove

### java와 리스트

- 이미 구현이 되어 있다

### 실습 ArrayList

- 

## 연결 리스트(Linked List)

### 연결리스트란

- 순서가 메모리 상의 물리적인 위치로 정의되지 않는 자료의 선형적 모임을 나타내는 자료 구조
- 값과 포인터(또는 래퍼런스)를 가진 Node의 집합으로 구현한다
  - 우리는 Head만 가지고 시작을한다

### 연산자

- 시작할때 head를 null로초기화하고 시작한다
- 리스트가 비어있는 확인하려면 Head가 null인지 확인하면된다
  - 값추가하면 head에 null값을 다음 노드에 넘겨주고 연결해주면 된다
- prepend
  - 서순이 중요하다
    - 노드하나를 만들고 얘가 헤드가 가르키던걸 가르키고 헤드가 얘를 가르키도록
    - 꼭 새로운 노드가 헤드가 가르키던 걸 먼저 가르켜야 된다. 그래야 헤드랑 연결이 된다
    - Head - 새로운애 - 첫노드였던애
- append
  - head에서 마지막 노드까지찾아간다
  - 마지막 노드에 연결하고 마지막노드가 null을 가지면 된다
  - head와 null사이에 노드가 있는거구나
- setHead
  - 인덱스를 먼저 찾아간다
  - 헤드가 얘를 가르키도록 하면 끝
  - 앞에는 알아서 가비지컬렉션된다
- Acess
  - 0번부터 순서대로 따라가서 값을 가져오면된다
- insert
  - 두개 사이에 들어가야되니 앞뒤로 관계를다시맺어줘야함
  - 앞에깨 보인을 본인은 앞에에가 가르키던걸 이어줘야함
    - 둘다해줘야 모양이 엮어진다
- remove
  - 앞에거가 그다음거를 가르키도록 해줘야 한다
  - current를 찾아오면서 prev로 가져와야만 연결을 할 수 있다

### 연결 리스트의 구현

- 복잡도
  - access때문에 다른작업들이 다 access가 된다
    - 이점때문에 araryList가 좋은것이고 그외에는 LinkedList가 좋다

### 양방향 연결리스트

- head - tail까지 연결된다
  - 노드가 prev와 next까지포함한다
    - 단방향이 아닌 반대방향으로도 access가 된다
    - 첫번재 값의 prev는 null이다.
- 장점은 한번에 마지막 노드에 접근할 수 있다
  - append가 O에1로 동작한다
- 실제로 많이 사용하는 연결 리스트이다.



## 스택(Stack)

### 스택이란

- 후입 선출의 특성을 가지는 ADT이다

- 자료가 입력된 순서의 역순으로 처리되어야 할 때 사용한다

  - 메소드 콜스택

    

### 스택의 연산자

- Push
  - 스택에 넣기
  - push를 더이상 할수 없을 경우 스택오버플로우 발생
    - 
- Pop
  - 맨위(Top)에 값 가져오기
  - 더이상 뺄수없을 때 언더플로우 발생
- Peek
  - 흘겨보기
  - 맨위(Top)에 값만 보기(빼진 않음)
- isEmpty
  - 비어있는지 확인
- Top은 두가지가있다
  - 맨위 값에 바로위 혹은 맨위 값
  - 이건 구현차이 우리는 맨위 값에 바로위(비어있는 값)

### 스택의 구현

 -  주로 배열을 사용한다

     -  크키가 정해져 있어서 속도가빠르다

     -  메모리상으로 연속되어 있기 때문에 속도가 빠르다

         -  스택은 입출이 많은 자료구조이기 때문에 빠르기가 중요하다

            

