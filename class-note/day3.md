# day3

## 과제리뷰

- prepend
  - head ==null 인경우를 isempty로 해도된다
  - node를 생성해서 하나씩 넣어주기
  - 사라지는 참조를 순서지켜서 해봐야한다
- append
  - tail.next를 해서 넣어주며됨 => 고쳐야겠다
  - prev를 this.tail하면 되겠다
- set haed
  - prev를 null 로해줘야함
- prev를 유지할 필요가 없다
- toStringInv구현하면 doubly로 잘구현됬는지 확인할수 있다



## 큐(Queue) 

### 큐란

- 큐는 선입선출(First In Ifrst Out; FiFO)의 특성을 가지는 추상 자료형(ADT)이다.
- 입력된 데이터가 순서대로 처리되어야 할 때 사용된다.
  - 네트워크 처리시 웹서버에서 우리서버로 넣어주기 전에 클라이언트의 요청들을 큐에 담아서 처리한다
    - 클라이언트 -> 웹서버(큐존재) -> 서버
  - 디도스 공격에 원리
    - 요청을 계속 넣어서 큐를 터트려버리고 서버가 뻗는것

### 큐의 연산자

- Put, Enqueue(ENQ)
  - 큐엔느 Front Rear가 있고 Rear로 들어가고 Front로 나온다
  - 더이상 들어갈수없는경우 오버플로우 발생
- Get, Dequue(DEQ)
  - Front에서 데이터를 뺀느것
  - 더이상 꺼낼수없으면 언더플로우 발생
- Peek
  - Front에 있는 자료를 반환하지만, 삭헤하지 않는다

### 큐의 구현

- 선형 큐(Linear Queue) == Trash
  - array로 capacity입력받아서 만들고 데이터를 하나씩 집어넣는다
  - front =0, rear= 0으로시작한다
  - rear는 데이터가 들어갈 곳을 가르킨다(스택과 마찬가지로)
  - 빼면  front를 인덱스를 올려주면된다
  - 문제는 array 범위를 넘어셔면 큐의용량을 다사용한게 되버린다
    - 이걸 위해 추가적인 구현들이 필요하게 되버린다
    - 반드시 오버플로우가 발생하게 된다 =>그래서 사용하지 않는다
- 참고 - Priority Queue
  - Heap 구조(=트리구조)
  - maximum이 항상 위에오도록하는 자료구조
  - 요런 큐랑은 다르다
- 환형 큐(Circular Queue)
  - 성형 큐의 끝 부분을 서로 연결하는 구조
  - 한번 사용한 메모리도 다시 활용할 수 있다
    - 큐의 용량을 모두 사용하기 전에는 Overflow가 발생하지 않음
  - 프론트가 전진한다면 비어있는 메모리는 사용할 수있다
  - 솔루션
    - isfull 책을 먼저 넣는다
    - rear %= capacity;\
      - rear가 capacity가 같게만들기
    - 그다음에 rear == front하면 is full인지 확인할 수 있다
      - 꽉차거나, 비어있을때 is full ture된다
      - 그래서 put에서는 같아지면  get하면 무조건 false가 되게 해야한다
    - get은 비어있거나 isfull하지 않으면 빼고 false만들어주면된다
    - toString
      - endIdx + capcity 를 추가
      - 실제로 구현할때는 다시 i%capacity 하면 제indx를찾아서 순서만 바꿔서 출력할 수 있다
- 연결리스트 큐(Linked Queue)
  - 더블리 링크드리스트 비슷
    - Head가 fornt로 가고 tail이 rear역할 하면된다
  - 물리적인 메모리를 모두 사용하기 전까지 Overflow가 발생하지 않음
  - append = put, get = remove(0)
  - has-A 관계로 구현할 수 있고
    - 더블리를 객체로 가지고 있어서 내부적으로 append와 remove를 사용하ㅕㄴㄴ되겠다
    - 구조적으로 다른점은 없고 기능만 제한되어있따

## 트리

## 트리의 구조

- 한부모는 자식이 없거나 하나 이상을 가질 수 있다
  - 우리는 둘까지 가질수 있는  binarytree를 주로 배울 것이다
- 처음배우는 비선형 자료구조
  - 참고로 트리여도 선형일 수 있다
- Root루트
  - 부모가 없는, 가장 상윗단의 노드
  - 뒤짚어진 형태로 뿌리가된다
- Node노드
  - 트리 구조의 자료값을 담고 있느 ㄴ요소
- 부모
  - 루트에 가까울수록 부모가 된다
- 리프노드
  - 자식이 없는 노드들을 모아서 리프노드라고한다
- 인터널 노드
  - 리프노드를 뺀 애들을 모두 인터널 노드라고 한다
- 뎁스
  - 루트 노드를 level 0
  - 루트 노드에 자식을 level1 = depth 1
  - 그자식들 모아서 level2 이런식으로 증가함
- 하이트(height)
  - 가장 높은 레벨(뎁스가 깊은)에 노드들을 뜻한다
  - level4인 노드가 하나만 있어도 height는 4가 된다
- 엣지(간선) - 사이간
  - 노드간에 연결선을 부르는말
- Path
  - 한노드와 어떤 노드간의 엣지들을 나열한것
  - 노드만 빠지고 엣지의 시퀀스

### 트리의 특징

- 하나의 노드에서 다른 노드로 이동하는 경로는 유일하다
  - 다른 곳을 갈길이 하나밖에는 없다
- Acyclic하다.(Cycle이 존재하지 않는다)
  - 하나의 노드에서 출발해서 다시 자신으로 돌아오는 길이 있으면 Cycle인다
  - 트리에서는 자신의 노드로 돌아오는 길은 없기에 Acyclic하다
- 모든 노드는 서로 연결되어 있다(외딴 섬이 존재하지 않는다)
- 하나의 Edge를 끊으면 두개의 Sub-Tree로 분리된다(항상)
  - 잘려진곳은 새로운 root가된다
  - root하나만 남아도 걔도 새로운 트리가 된다
- Edge의 수는 Node의 수 -1 이다
  - 심플

## 이진트리(Binary Tree)

- 총4가지 형태로 나타난다
  - 루트만 있거나 왼쪽자식 오른쪽자식 둘다 잇는경우

### 이진 트리의 종류

- 정 이진 트리(Full Binary Tree, Perfect Binary Tree)
  - 자식이 꽉차있어서 full, 완전히 채워져이싿고해서 Perfect
  - 다루기가 쉽다

- 완전 이진트리 (Complete Binary Tree)
  - 가장 많이쓰인다 == 가장 중요하다
    - 이름이 햇깔리니까 외워둬야 한다
  - full 이랑 거의 비슷한데 height가 3이면 n-1까지는 꽉차있ek
    - 리프노드가 왼쪽에서 오른쪽으로 연결되있는건 꽉차있고 그외에는 비어있는것
    - full은 complete에 포함된다
- 균형 이진트리
  - Skewed Tree
    - 루트기준으로 좌우가 밸런스가 안맞고 쏠려있는애
  - Balanced Binary Tree
    - 좌우 밸런스가 맞는 애
    - 정확히 정의는 안되어있지만 용도에 따라서 정의해서 쓴다
      - 균형이 잡힐 필요가 있는 알고리즘에서 정의해서 사용한다
      - 해당 알고리즘에서 필요한 조건들을 활용해서 쓴다
      - 그중 하나가 리프노드에 최대 노드 차이가 1이하 인것
      - 루트기준 왼쪽에 노드와 오른쪽노드 수가 차이가 3개이하인 경우

### 이진 트리의 순회(Traversal)

- 선형 자료의 경우 데이터를 접근하는데 순서대로 보면된다, 쉽다
- 이진트리의 경우는 어떤 순서로 순회해서 접근할지가 정해져있지 않기 때문에 방법이 여러가지가 있다

#### 깊이 우선 순회(Preorder, Depth-First Traversal)

- 루트부터 시작해서 node -> left -> right
  - 루트 노드보고나서 left를 보고 새로운 노드만나고 다시 left보고 다시 새로운노드 left...
    - 리컬시브하게 동작한다
- 가장 많이 사용한다

#### 대칭 순회(Inorder, Sysmetric Traversal)

- left -> node > right
- node를 먼저 보지 않기 때문에 제일 left까지 간다
  - 새로운 노드가면 무조건 left먼저본다

#### 후위 순회(Postorder)

- left->right-> node

### 이진 트리의 탐색(Search)

- 값을 찾는 것
- 찾는 순서를 보는 것이다
- 순회랑은 기능이 다르다

#### 너비 우선 탐색(Breadth-First Serach; BFS)

- level오름차순으로 왼쪽에서 오른쪽으로 다보고 다음 level로 넘어가는 것
  - 값을 찾으면 retrun true
  - 끝까지 다봤는데 없으면 return false

#### 깊이 우선 탐색(Depth =First Search; DFS)

- 프리오더랑 같은순서 node-left-right
  - 가장 깊은 순서로 먼저 훑고 시작한다

### 트리 구현

#### 배열을 이용한 구현

- 트리를 배열로 표현했을때 꽉찬 트리가 완전이진트리이다
  - 배열이 번호가 안뜨고 꽉찰수 있따
- 치트키
  - left는 node에 *2+1을 하면된다
  - rifhtg node에 *2+2를 하면된다

####  풀이

- preorder
  - 리컬시브하게ㅎ해야도기때문에 새로운 메소드만드는게 좋다
  - 































