# day1

## Courcse Overview

### 목표

- 기본 자료구조와 알고리즘을 이해하고 구현할 수 있다
- 초급 단계의 코딩 테스트 문제를 직접 해결할 수 있다

- 주어진 문제를 이해하고 어떤 자료구조와 알고리즘을 선택하는지 알수있어야 한다



## Instroduction

### Data Structures

- 자료 : 현실 세계로부터 수집한 사실이나 개념의 값 또는 이들의 집합.(가치관 , 목적 없는 값들의 모음)
  - A반 B반이 있고 각각 학생별 점수가 있다
    - 점수는 사실이기 때문에 데이터가 된다
  - 개념의 값은 IQ EQ같은 예가 있다
  - 혹은 A와 B가 모여있는것 전체가 데이터가 될 수 있다.
    - 숫자가 아니라 데이터가 모여었기만 하면 마찬가지로 데이터라고 부른다
  - 이것들을 가공한 것을 정보 라고 한다(가치관, 목적이 있게 가공된 값들의 모음)
    - A반 B반의 평균을 내면 된다
      - 이값을 가지고 어디가 더좋다고 말을 할 수 있게 된다
      - 통계적인 값을 가지게 된다
- 자료구조(Data Structure)
  - 자료들의 모임, 자료 간의 관계, 자료에 적용할 수 있는 함수나 명령을 의미한다.
    - 자료값의 모임 : A라는 반에 점수를 모은다고 하면 단순히 집합 뿐 아니라 특정한 형태의 모임으로 볼수도 있다
      - 모이는 방법은 자료의 관계로 정할 수 있다.
        -  97다음 98 다음 3 다음 32 같이 순서로 정할수도 있다
      - 자식과 부모의 모근갯수 - > 부모와 자신관계라는 관계가 발생
        - 손자가 부몰를 잃으면 orphant가 된다
        - 트리자료구조에 자료를 하나 삭제하기 위한 그에 다른 사이드이펙트 다른 작업들도 해줘야한다
          - 특별한 함수나 명령을 맣낟
  - 자료구조를 배우면 자료구조에서 자료들이 어떤 관계를 맺고 해당 자료구조에서 사용하는 특정한 함수들을 떠올리면 된다

#### 자료구조 특징

- 효율성(Efficiency) : 특정한 상황에서 효율성 높아야 한다. 어떤 상황에도 효율성 높은 자료구조는 없다
- 추상화(Abstraction)  : 인터페이스를 사용하듯이 추상화된 자료구조가 있고 그 자료구조 내부에 해당 자료구조를 구현하기 위한 동작들이 구현되어있을 것이다
  - 하지만 처음에 원리만 이해하고 내부구현은 크게 개의치 않고 잘 활용하면 된다.(추상화가 잘되어있는걸 잘사용하면 된다)
- 재사용성(Reusabillity)
  - 아주특별한 상황에 아주 효율이 좋은것보단 어느정도 특정한 상황에 어느정도 효율이 좋은것이 더좋은 구현이 되는 자료구조다

#### 자료구조의 종류

- 선형구조
  - 일자로 되어 있는 구조, 쉽다
  - Sequential List
  - LinkedList
    - 노드가 있어서 다음 자료에 연결되어 있는것
  - 
- 비선형구조
  - 일자로 되어 있지 않다. 어렵다
  - Graph : 자료들이 어떻게든 열결할 수 있는것
  - Tree: 부모와 자식관계면 Tree . 자식의 숫자는 정해져있지 않다
    - 부모는 여럿이 될수가 없다
    - TOP(꼭대기있는애)

### 자료구조의 필요성

- 프로그램에서는 다양한 자료를 임시(메모리)/영구적(파일시스템, 데이터베이스)으로 저장하여 사용한다
- 만능인 자료구조는 없다. 상황에 따라 적절한 자료구조를 선택하여 사용해야 한다.
- 자료구조의 선택(자료를 어떻게 저장할지)는 프로그램에 다음과 같은 중대한 영향을 끼친다
  - 필요한 자료에 효율적으로 빠르게 접근할 수 있게 한다.
    - 아무리 많이 저장되도 속도가 느리면 사용하지 못한다
  - 자료의 중복을 최소하여 저장장치를 효율적으로 사용할 수 있게 한다
    - 위에 두가지가 트레이드 오프
    - 속도와 사용공간은 기본적으로 반비례 관계이기 때문이다
  - 자료구조 별로 적절한 알고리즘을 기계적으로 적용할 수 있다.
    - 그래프로 네비게이션 구한다고 하면 다익스트라 알고리즘 사용하면 된다
    - 효율적으로 계산하기 위한 계산을 이미 알고리즘이 가지고 있다
      - 만약 그래프로 표현하지 않았다면 다익스트라 알고리즘을 사용할 수 없다
      - 새로자료구조를 만들어서 사용하여야 할 수 도 있다
  - 동료들고 협엽하는데 큰 도움이 된다. 잘못된 창의성을 발휘하지 않게 도와준다.
    - A라는 자료구조 쓰고 B라는 알고리즘을 사용했습니다. 하면 끝날걸 스스로 구현해서 사용하면 다른사람이 이해를 못한다
    - 커스텀 자료구조와 알고리즘이 더 효율적일수도 있지만 그것은 한글을 꿸빼쁅뇁과 같이 사용하는 것이다
      - 컨벤션을 지키면서하는게 얼마나 효율적인지를 잘이해를 못하고 있는 것이다
  - 코딩테스트

### Java와 자료구조

- JAva에는 대부분의 자료구조가 Java Collections Framework에 구현되어 있다.
  - List
    - 제네릭 인터페이스를 기본으로 사용하는게 좋다. Object는 불안하다
  - Map
  - Set



## 알고리즘

### 알고리즘 정의

- 문제를 해결하기 위한 여러 동작들의 모임
  - 동작들이 명명백백해야 한다 

### 알고리즘 조건

- 입력 : 외부에서 제공되는 자료가 존재한다
- 출력 : 적어도 2가지 이상의 다른 결과를 출력해야 한다.(입력이 다르면 결과가 다를 수도 있어야 한다) 즉, 모든 입력에 대해 동일한 출력을 내서는 안된다.(모든것 계산해서 무조건 0이 나오면 의미가 없다는 것, 최소한 2가지 이상 결과값이 있어야 한다)
  - 2가지 만 출력해도 의미가 있나? 있다 ture/false
  - 입력하나는 하나의 출력으로 나오지만 출력은 여러개의 입력의 결과가 될 수 있다
  - N:1관계가 된다.
- 명확성 : 수행 과정은 명확한 명령어로 구성되어 있어야 한다.
  - 동작하나하나가 명확해야 한다 = 코드로 작성할 수 있어야 한다 = 너무 명확해서 컴퓨터에게 알려줄수도 있어야 한다
  - 사원 앞으로 옮기는 문제
    - 1 맨앞에 맨 왼쪽에 앉은 사원을 선택
    - 2 더앞으로 갈수있는지확인
    - 3 앞으로 한칸 옮긴다
    - 4 더앞으로 못가면 제외한다
    - 4 notDone은 더 옮길 수 있는 학생이 있는지 확인 한다
    - 이런식으로 동작이 명확히 구분되야 한다
- 유한성 : 유한한 시간 안에 종료되어야 한다.(무한루프가 있으면 안된다) 프로그램자체는 무한루프로 돌수 있지만 그안에 입출력해주는 모듈이 알고리즘이다.
- 효과성 : 모든 과정이 사람이 종이와 연필로 유한한 시간안에 수핼할 정도로 단순/명백 해야 한다.
  - 조금 애매할 수 있는 기준이지만 자료가 적다면 종이와 연필로 할수있을정도로 단순하고 명쾌해야 한다는 뜻

### 알고리즘 필요성

#### 서비스의 규모

- 서비스의 규모가 어마어마하게 커지고 있다
  - 10만명에 회원에게 100만가지 아이템을 연관시키려면??.. 그냥 매트릭스를 가지고는 아무것도할 수가 없다

### 컴퓨터의 연산 속도와 비용

- 최근에는 많은 기업이 클라우드 서비서를 제공한다
  - 물리적으로 구매/유지/관리하는 비용을 아낄수 있다
  - 보안과 안정성등 소모 기업이 직접 해결하기 어려운 문제를 쉽게 해결할 수 있다
- 연산 = 비용
  - 임대한 서버의 Spec과 시간에 비례해서 비용이 청구된다
  - 더 좋은 알고리즘으로 연산 속도를 개선한 경우 더 낮은 서버 Spec으로도 동일한 서비스를 제공할 수 있따
  - 동일한 Batch 작업에 더 좋은 알고리즘을 사용할 경우, 동일한 서버 Spec으로 더 짧은 시간 서버를 임대해도 동일한 결과를 얻어낼 수 있다
    - => 이런부분이 알고리즘이 돈과 직관적인 부분(백엔드 분야에서)



### Java와 알고리즘

- Java는 High-Level Language로서 알고리즘을 효율적으로 구현하기 위한 언어는 아니다
  - JVM위에서 돌아가기 때문에 효율은 높지 않지만 다른 장정도 있다
  - OOP, Typed언어, Functional Programmin을 모두 지원한다
    - 잘 짜여진 자료구조/알고리즘을 구현할 수 있고 Mission Critical한 로직만 구혈할 수도 있다
  - 구현해서 코드를 구동속도도 중상정도...
- java로 하는게 최고는 아니지만 나쁘지 않다. 



## Coding Test

### 코딩 테스트 목적

- 빠르고 효율적으로 개발자의 실력을 가늠하기 위해 사용된다
- 개발자의 코딩 습관을 간접적으로 확인할 수 있다
  - 게터세터, OOP(적당히), 변수명 => 이건간접적
- 공통적으로 개발자가 필요로 하는 역량을 준비할 수 있다
  - 회사에서 내는 문제이기 때문에 고통을 주는게 아닌 개발자가 필요로 하는 역량을 알려주는 창구라고 볼수있다

### 출제유형

- 프로그래밍 언어의 기본 라이브러리를 이용한 효율적인 구현 => 가장 기본적인 출제유형 반드시 나옴
  - 반복문과 조건문을 이용한 기능 구현
  - Array 검색, 정렬
  - 예외처리(예외적인 입력을 어떻게 처리할 것인가)
  - String 관련 메소드 사용
- 자료구조를 이용한 기본구현
  - 자료구조만 잘 사용하면 푸는 문제
  - Map, Set, Heap등 특수한 기능을 갖춘 자료주로 활용하는 문제. 
  - 자료구조만 잘 선택하면 자연스럽게 풀리는 문제
- 잘 알려진 알고리즘 활용
  - 다이나믹 프로그래밍(많이 중요), DFS, BFS, Greddy, Dijkstra등은 잘배워서 사용하는 문제, 생각해서 푸는건 불가능
  - 자료구조와 더불어, 알고리즘을 숙지하고 구현해야 해결할 수 있는 문제
- 규격 외의 문제
  - 잘 나오지 않는다.. 고난이도 문제, 올림피아드 문제

### Java와 Coding Test

- 코딩테스트에 많이 사용되는 언어
  - C or C++ : 예전에 많이 사용된다
  - Python : 요즘 제일 많이 사용된다 => 배우고싶으면 그냥 공부해라
  - Java : C와 Python 사이에서 장단점을 가졌다
- Java의 특징



## Baiscs

### 입출력 처리

- 백준은 scanner로 입력받아 system out으로 출력한다
- 프로그래머스는 Soulution 이라는 클래스를 만들고 solution 메소드를 만들어서 해결하게 하는 스타일

### 테스트 입출력을 IDE에 구현해서 쓰면 좋은 이유

- 테스트 디버깅이 불리하다
- 페이지 오류로 소스코드를 날리수 있따
- IDE를 활용하면 도움이 많이 된다



## Java

### 좋은습관 나쁜습관

- 좋은습관
  - 변수명을 정할 때 의미가 있는 이름으로 결정
  - 변수 , 클래스 명 등은 컨벤션을 지켜서 일정하게 구현(노테이션 적절히사용)
  - Stream API의 map, filter 등을 이용하여 함수형 프로그래밍을 적절하게 채용
    - 짧고 간결하고 일목요연하게 작성이 가능하다
- 나쁜 습관
  - 신기한코드
  - 무조건 짧은 코드
  - 무조건 내가 구현
  - 무조건 최적화
    - 가독성이 떨어질수가 있기 때문에 상황에 맞게 결정한다.

## 알고리즘 복잡도

- 알고리즘이 복잡한 정도 두가지 종류가 있다
  - 공간복잡도 vs 시간 복잡도 -> 일반적으로 두 복잡도는 Trade-Off관게가 있다
  - 공간복잡도는 메모리 사용량 , 시간복잡도는 동작하는데 걸리는시간, 연산의 횟수
- 알고리즘의 복잡도가 높을수록 알고리즘을 구동하는 데에 더 많은 Cost가 소비된다.

### 공간복잡도

- 알고리즘이 동작하기 위해 필요한 공간의 크기
- 연산의 중간 결과를 저장하기 위해 메모리를 소비한다.
  - 중간 결과를 저장하여 중복 연산을 줄일 수 있다.
- 알고리즘이 성능차이가 있기 때문에 모든 알고리즘에서 트레이드 오프가 생기지는 않는다
  - 트레이드 오프가 생기는 경우는 더이상 좋은 알고리즘을 찾지 못했을때의 트레이드 오프가 성립되게 된다

### 시간 복잡도

-  알고리즘이 동작하는데 걸리는 시간 또는 연산의 횟수
  - 시간보다는 연산의 횟수로 얘기하는게 좋다
  - 똑같은 알고리즘이더라도 서로 다른 머신에서 동작을 할때 속도가 다를 수 있기 때문이다(그건 장비차이지 알고리즘 차이가 아니다)

### 복잡도의 계산 방법

- 공간복잡도는 쉽기 때문에 하지 않는다
- 시간복잡도 계산 방법
  - 알고리즘을 구동하면서 Elementary Operation(기본연산)의 횟수를 카운팅하여 측정할 수 있다.
    - 기본연산 -> 대입, 덧셈 등 더 쪼갤수 없는 가장 작은 연산
  - 연산이 들어갈 때마다 count를 플러스 해주는 방법
  - Branch라고?
  - 논란이 될 수 있는 부분이 있다 -> 기본 연산을 어디까지 볼 것인가
  - 숫자로 결과가 나오기 때문에 이게 빠른지 느린지 모르다
- 분석을 하는 방법
  - 반복문과 조건문을 고려하여 분기별로 실행 횟수를 통해 알아 낼 수 있다
  - 엘레멘트 갯수를 n 개라고 하면 for문은 n번 동작하게 된다
    - 자료가 전혀 없으면 0이되고 1개면 3이고 2개면 6이 된다

### 복잡도의 종류

- List에 Element Inserition 에 경우에 최선과 최악의 경우
  - m=8 일때 자료를 끝에 넣으면 최선에 경우 -> 1이나온다
  - m=8 일때 자료를 처음에 넣으면 모두한칸씩 옮겨야되서 n개를 옮기고 하나를 처음에 넣으면 n+1이 나온다
  - 평균적인 경우는 모든 경우의 수를 계산해서 구한다
    - 맨뒤에서 앞칸에 넣는경우, 그앞칸에 넣는거... 쭉해서 1~ n+1까지 1씩 증가한다
    - (n+1)(n+2)/2 하고 평균을 위해 n으로 나눈다
      - 앞에건 총수 뒤에것은 n으로 나누어 평균구하기
  - 평균 구하기 어렵기 때문에 최악의 경우만 가지고 평가를 한다
    - 평균은 필요한 경우에만 하게 된다
- Asymptotic Notations
  - 성능 평가에 공평한 비교를 하기 위한 성능 분석 기준으로 사용
  - 점진적 표기 방법 이다(Limit를 얘기한다)
    - 그래프가 어떻게 되어 있던 마지막에 결국 어떻게 되는지만 알면된다
  - 알고리즘에 입력되는 자료의 개수가 충분히 많다고 가정한다
  - 동작시스템 (시간)무시 데이터 크기(n)으로 놓고 성능을 비교하기 위해 필요

- Big-O Notation
  - O(g(n))이라고 표시 해준다
  - f(n)이라는 함수를 O(g(n)) 형태로 바꿔주는게 목표이다
    - 그걸 바꿔주는 정의가 있다
    - 그전에 개념적을 보자
      - 더이상역전이 나지 않는 부분을 N0으로 둔다.(그부분만 관심 영역)
      - f(n)이 n제곱 +3일 때  cg(n)을 2*n2일 때 역전되는 그래프가 그려진다
    - O(n2)은 집합인데  a n2 + O(n) 등이 포함된 집합이다
      - O(logn) < O(n) 

- 복잡도 순위
  - 상수가 가장빠르고 n! 패토리얼이 가장 느리다

- Big-Omega NOtation
  - 이번엔 f(n)이 cgn(n)보다 빠른 경우
  - 빅오는 빠른게 다들어가고 오메가는 더느린게 다들어간다
- Big-Theta Notaion
  - 빅 오에도 들어가고 빅 오메가에도 들어가야 빅 세타에 속할수있따
    - n2이 최고차수인 것만 포함이 된다
    - 3n 4n3 못들어간다..



- 다시 정리

- 그래프상으로는 높은게 더 느린것이다, 알고리즘은 아래에 있는건 빠른거고( y축이 시간복잡도)
  - O(g(n)) 이라는 집합이 있다
    - g(n) = n2인 경우
    - O(n2)은 fn들이 들어있는 집합
      - 어떤 fn인가 하면 0이상이고 g(n)에다가 c(임의에)를 곱한거보다 이하에 존재하는 f(n) 들이다
      - n에 조건은 n0일때 이고 n0은 더이상 2개가 역전되지 않는 최소의 숫자
        - 앞에것은 보지 않는다
      - c는 0보다 큰 아무숫자나 된다
    - 어떤 f(n)이 o(n2)에 속하나 안속하나 알려고 하면 3n인이 n2보다 높인지알려면 그래프를 그려
      - 그려서 cg(n)보다 그래프가 아래에 있으면 해당것도 속한다(c에 값을 곱해주면 된다)
    - fn은 어떤 시간복잡이고 g(n)이 기준이 되는 시간 복잡도이다
      - fn이 cgn에 포함되냐 안되냐를 지금 판단하는 것!
    - 결론은 gn이 가장빠른항이고 그 하위에 것들은 무엇이 붙어도 상관없다(더빠른게 붙으면 포함이 안된다)
  - 오메가는 더 느린것만 모아놓은것, 세타는 정확히 일치하는것만 모아놓은것

- 왜 빅오 노테이션을 주로 사용한는가?
  - 아래 기준이 명확하게 계산하기 어렵기 때문에 큰 바운더리만 주면 사용하기가 편하기 때문이다
  - On으로 구현하라고 하면 n+5로 해도되지만 3으로 해도된다
  - 입력값에 따라 같은 알고리즘이어도 n2도 될수 있고 n도 될 수 있다. 하지만 세타로 묶어버릴경우 어디에 포함되는지 표현을 할 수 가없다. 그래서 최악의 경우만 따져서 빅오로 넣고 그아래 값들은 자연스럽게 포함될 수 있게 하는것으로 하며된다.

상수가 제일 빠른거다

















